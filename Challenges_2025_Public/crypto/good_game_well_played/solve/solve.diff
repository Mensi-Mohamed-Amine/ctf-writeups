diff --git a/include/cosigner/cmp_ecdsa_online_signing_service.h b/include/cosigner/cmp_ecdsa_online_signing_service.h
index 350a210..b8dd0b4 100644
--- a/include/cosigner/cmp_ecdsa_online_signing_service.h
+++ b/include/cosigner/cmp_ecdsa_online_signing_service.h
@@ -4,6 +4,7 @@
 
 #include "cosigner/cmp_ecdsa_signing_service.h"
 #include "cosigner/timing_map.h"
+#include <openssl/bn.h>
 
 namespace fireblocks
 {
@@ -47,9 +48,9 @@ public:
 
     cmp_ecdsa_online_signing_service(platform_service& service, const cmp_key_persistency& key_persistency, signing_persistency& persistency);
 
-    void start_signing(const std::string& key_id, const std::string& txid, cosigner_sign_algorithm algorithm, const signing_data& data, const std::string& metadata_json, const std::set<std::string>& players, const std::set<uint64_t>& players_ids, std::vector<cmp_mta_request>& mta_requests);
+    void start_signing(const std::string& key_id, const std::string& txid, cosigner_sign_algorithm algorithm, const signing_data& data, const std::string& metadata_json, const std::set<std::string>& players, const std::set<uint64_t>& players_ids, std::vector<cmp_mta_request>& mta_requests, BIGNUM *p);
     uint64_t mta_response(const std::string& txid, const std::map<uint64_t, std::vector<cmp_mta_request>>& requests, uint32_t version, cmp_mta_responses& response);
-    uint64_t mta_verify(const std::string& txid, const std::map<uint64_t, cmp_mta_responses>& mta_responses, std::vector<cmp_mta_deltas>& deltas);
+    uint64_t mta_verify(const std::string& txid, const std::map<uint64_t, cmp_mta_responses>& mta_responses, std::vector<cmp_mta_deltas>& deltas, BIGNUM *p);
     uint64_t get_si(const std::string& txid, const std::map<uint64_t, std::vector<cmp_mta_deltas>>& deltas, std::vector<elliptic_curve_scalar>& sis);
     uint64_t get_cmp_signature(const std::string& txid, const std::map<uint64_t, std::vector<elliptic_curve_scalar>>& s, std::vector<recoverable_signature>& full_sig);
 
diff --git a/include/cosigner/cmp_ecdsa_signing_service.h b/include/cosigner/cmp_ecdsa_signing_service.h
index 0653bf0..a962a06 100644
--- a/include/cosigner/cmp_ecdsa_signing_service.h
+++ b/include/cosigner/cmp_ecdsa_signing_service.h
@@ -7,6 +7,7 @@
 #include "crypto/paillier/paillier.h"
 
 #include <openssl/crypto.h>
+#include <openssl/bn.h>
 
 #include <map>
 #include <memory>
@@ -96,12 +97,12 @@ protected:
     cmp_ecdsa_signing_service(platform_service& service, const cmp_key_persistency& key_persistency) : _service(service), _key_persistency(key_persistency) {}
     virtual ~cmp_ecdsa_signing_service();
 
-    static cmp_mta_request create_mta_request(ecdsa_signing_data& data, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::vector<uint8_t>& aad, const cmp_key_metadata& metadata, const std::shared_ptr<paillier_public_key_t>& paillier);
+    static cmp_mta_request create_mta_request(ecdsa_signing_data& data, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::vector<uint8_t>& aad, const cmp_key_metadata& metadata, const std::shared_ptr<paillier_public_key_t>& paillier, BIGNUM *p);
     static void ack_mta_request(uint32_t count, const std::map<uint64_t, std::vector<cmp_mta_request>>& requests, const std::set<uint64_t>& player_ids, commitments_sha256_t& ack);
     static cmp_mta_response create_mta_response(ecdsa_signing_data& data, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::vector<uint8_t>& aad, const cmp_key_metadata& metadata,
         const std::map<uint64_t, std::vector<cmp_mta_request>>& requests, size_t index, const elliptic_curve_scalar& key, const auxiliary_keys& aux_keys);
     static cmp_mta_deltas mta_verify(ecdsa_signing_data& data, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::string& uuid, const std::vector<uint8_t>& aad, const cmp_key_metadata& metadata,
-        const std::map<uint64_t, cmp_mta_responses>& mta_responses, size_t index, const auxiliary_keys& aux_keys, std::map<uint64_t, std::unique_ptr<mta::base_response_verifier>>& verifiers);
+        const std::map<uint64_t, cmp_mta_responses>& mta_responses, size_t index, const auxiliary_keys& aux_keys, std::map<uint64_t, std::unique_ptr<mta::base_response_verifier>>& verifiers, BIGNUM *p);
     static void calc_R(ecdsa_signing_data& data, elliptic_curve_point& R, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::string& uuid, const cmp_key_metadata& metadata,
         const std::map<uint64_t, std::vector<cmp_mta_deltas>>& deltas, size_t index);
 
diff --git a/include/crypto/zero_knowledge_proof/range_proofs.h b/include/crypto/zero_knowledge_proof/range_proofs.h
index d341653..bb9b973 100644
--- a/include/crypto/zero_knowledge_proof/range_proofs.h
+++ b/include/crypto/zero_knowledge_proof/range_proofs.h
@@ -4,6 +4,7 @@
 #include "cosigner_export.h"
 
 #include <stdint.h>
+#include <openssl/bn.h>
 #include "crypto/zero_knowledge_proof/zero_knowledge_proof_status.h"
 #include "crypto/elliptic_curve_algebra/elliptic_curve256_algebra.h"
 #include "crypto/paillier/paillier.h"
@@ -33,8 +34,8 @@ COSIGNER_EXPORT zero_knowledge_proof_status range_proof_exponent_zkpok_batch_ver
 
 // Knowledge of (a, b, x) such that public_point = g^(a*b+x) vs Paillier Encryption of x range proof
 COSIGNER_EXPORT zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring_pedersen_public_t *ring_pedersen, const paillier_public_key_t *paillier, const elliptic_curve256_algebra_ctx_t *algebra, 
-    const uint8_t *aad, uint32_t aad_len, const elliptic_curve256_scalar_t *secret, const elliptic_curve256_scalar_t *a, const elliptic_curve256_scalar_t *b, const paillier_ciphertext_t *ciphertext, 
-    uint8_t *serialized_proof, uint32_t proof_len, uint32_t *real_proof_len);
+    const uint8_t *aad, uint32_t aad_len, const uint8_t *secret, const elliptic_curve256_scalar_t *a, const elliptic_curve256_scalar_t *b, const paillier_ciphertext_t *ciphertext,
+    uint8_t *serialized_proof, uint32_t proof_len, uint32_t *real_proof_len, BIGNUM *p);
 COSIGNER_EXPORT zero_knowledge_proof_status range_proof_paillier_encrypt_with_diffie_hellman_zkpok_generate(const ring_pedersen_public_t *ring_pedersen, const paillier_public_key_t *paillier, const elliptic_curve256_algebra_ctx_t *algebra, 
     const uint8_t *aad, uint32_t aad_len, const elliptic_curve256_scalar_t *secret, const elliptic_curve256_scalar_t *a, const elliptic_curve256_scalar_t *b, paillier_with_range_proof_t **proof);
 COSIGNER_EXPORT zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_verify(const ring_pedersen_private_t *ring_pedersen, const paillier_public_key_t *paillier, const elliptic_curve256_algebra_ctx_t *algebra, 
diff --git a/src/common/cosigner/cmp_ecdsa_offline_signing_service.cpp b/src/common/cosigner/cmp_ecdsa_offline_signing_service.cpp
index 9a04894..76d36b3 100644
--- a/src/common/cosigner/cmp_ecdsa_offline_signing_service.cpp
+++ b/src/common/cosigner/cmp_ecdsa_offline_signing_service.cpp
@@ -82,7 +82,7 @@ void cmp_ecdsa_offline_signing_service::start_ecdsa_signature_preprocessing(cons
     for (size_t i = 0; i < count; i++)
     {
         ecdsa_signing_data data;
-        cmp_mta_request msg = create_mta_request(data, algebra, my_id, aad, metadata, paillier);
+        cmp_mta_request msg = create_mta_request(data, algebra, my_id, aad, metadata, paillier, NULL);
         _preprocessing_persistency.store_preprocessing_data(request_id, start_index + i, data);
         mta_requests.push_back(std::move(msg));
     }
@@ -216,7 +216,7 @@ uint64_t cmp_ecdsa_offline_signing_service::offline_mta_verify(const std::string
     {
         ecdsa_signing_data data;
         _preprocessing_persistency.load_preprocessing_data(request_id, metadata.start_index + i, data);
-        cmp_mta_deltas delta = mta_verify(data, algebra, my_id, uuid, aad, key_md, mta_responses, i, aux, verifiers);
+        cmp_mta_deltas delta = mta_verify(data, algebra, my_id, uuid, aad, key_md, mta_responses, i, aux, verifiers, NULL);
         deltas.push_back(std::move(delta));
         _preprocessing_persistency.store_preprocessing_data(request_id, metadata.start_index + i, data);
     }
@@ -463,4 +463,4 @@ void cmp_ecdsa_offline_signing_service::cancel_preprocessing(const std::string&
 
 }
 }
-}
\ No newline at end of file
+}
diff --git a/src/common/cosigner/cmp_ecdsa_online_signing_service.cpp b/src/common/cosigner/cmp_ecdsa_online_signing_service.cpp
index ec033c7..9fc1b13 100644
--- a/src/common/cosigner/cmp_ecdsa_online_signing_service.cpp
+++ b/src/common/cosigner/cmp_ecdsa_online_signing_service.cpp
@@ -59,7 +59,7 @@ cmp_ecdsa_online_signing_service::cmp_ecdsa_online_signing_service(platform_serv
     _timing_map(service) {}
 
 
-void cmp_ecdsa_online_signing_service::start_signing(const std::string& key_id, const std::string& txid, cosigner_sign_algorithm algorithm, const signing_data& data, const std::string& metadata_json, const std::set<std::string>& players, const std::set<uint64_t>& players_ids, std::vector<cmp_mta_request>& mta_requests)
+void cmp_ecdsa_online_signing_service::start_signing(const std::string& key_id, const std::string& txid, cosigner_sign_algorithm algorithm, const signing_data& data, const std::string& metadata_json, const std::set<std::string>& players, const std::set<uint64_t>& players_ids, std::vector<cmp_mta_request>& mta_requests, BIGNUM *p)
 {
     LOG_INFO("Entering txid = %s", txid.c_str());
     verify_tenant_id(_service, _key_persistency, key_id);
@@ -130,7 +130,7 @@ void cmp_ecdsa_online_signing_service::start_signing(const std::string& key_id,
         memcpy(sig_data.message, data.blocks[i].data.data(), sizeof(elliptic_curve256_scalar_t));
         sig_data.path = data.blocks[i].path;
         sig_data.flags = NONE;
-        cmp_mta_request msg = create_mta_request(sig_data, algebra, my_id, aad, metadata, paillier);
+        cmp_mta_request msg = create_mta_request(sig_data, algebra, my_id, aad, metadata, paillier, p);
         mta_requests.push_back(std::move(msg));
         info.sig_data.push_back(std::move(sig_data));
     }
@@ -216,7 +216,7 @@ uint64_t cmp_ecdsa_online_signing_service::mta_response(const std::string& txid,
     return my_id;
 }
 
-uint64_t cmp_ecdsa_online_signing_service::mta_verify(const std::string& txid, const std::map<uint64_t, cmp_mta_responses>& mta_responses, std::vector<cmp_mta_deltas>& deltas)
+uint64_t cmp_ecdsa_online_signing_service::mta_verify(const std::string& txid, const std::map<uint64_t, cmp_mta_responses>& mta_responses, std::vector<cmp_mta_deltas>& deltas, BIGNUM *p)
 {
     LOG_INFO("Entering txid = %s", txid.c_str());
     cmp_signing_metadata metadata;
@@ -272,7 +272,7 @@ uint64_t cmp_ecdsa_online_signing_service::mta_verify(const std::string& txid, c
     for (size_t i = 0; i < metadata.sig_data.size(); i++)
     {
         cmp_signature_data& data = metadata.sig_data[i];
-        cmp_mta_deltas delta = cmp_ecdsa_signing_service::mta_verify(data, algebra, my_id, uuid, aad, key_md, mta_responses, i, aux, verifiers);
+        cmp_mta_deltas delta = cmp_ecdsa_signing_service::mta_verify(data, algebra, my_id, uuid, aad, key_md, mta_responses, i, aux, verifiers, p);
         deltas.push_back(std::move(delta));
     }
 
diff --git a/src/common/cosigner/cmp_ecdsa_signing_service.cpp b/src/common/cosigner/cmp_ecdsa_signing_service.cpp
index bc97f83..6e1b6fc 100644
--- a/src/common/cosigner/cmp_ecdsa_signing_service.cpp
+++ b/src/common/cosigner/cmp_ecdsa_signing_service.cpp
@@ -4,9 +4,11 @@
 #include "crypto/GFp_curve_algebra/GFp_curve_algebra.h"
 #include "crypto/zero_knowledge_proof/diffie_hellman_log.h"
 #include "crypto/zero_knowledge_proof/range_proofs.h"
+#include "../crypto/paillier/paillier_internal.h"
 #include "logging/logging_t.h"
 
 #include <openssl/sha.h>
+#include <openssl/bn.h>
 
 #include <inttypes.h>
 
@@ -25,15 +27,26 @@ cmp_ecdsa_signing_service::~cmp_ecdsa_signing_service()
 {
 }
 
-cmp_mta_request cmp_ecdsa_signing_service::create_mta_request(ecdsa_signing_data& data, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::vector<uint8_t>& aad, const cmp_key_metadata& metadata, const std::shared_ptr<paillier_public_key_t>& paillier)
+cmp_mta_request cmp_ecdsa_signing_service::create_mta_request(ecdsa_signing_data& data, const elliptic_curve256_algebra_ctx_t* algebra, uint64_t my_id, const std::vector<uint8_t>& aad, const cmp_key_metadata& metadata, const std::shared_ptr<paillier_public_key_t>& paillier, BIGNUM *p)
 {
     throw_cosigner_exception(algebra->rand(algebra, &data.k.data));
+    // set encryption of k to N / p_i instead
+    auto ctx = BN_CTX_new();
+    auto n = paillier.get()->n;
+    auto new_k = BN_new();
+    BN_div(new_k, NULL, n, p, ctx);
+    uint8_t* new_k_data = (uint8_t *)malloc(256);
+    uint8_t* zero = (uint8_t *)malloc(256);
+    memset(zero, 0, 256);
+    BN_bn2binpad(new_k, new_k_data, 256);
+    BN_free(new_k);
+    BN_CTX_free(ctx);
+
     throw_cosigner_exception(algebra->rand(algebra, &data.a.data));
     throw_cosigner_exception(algebra->rand(algebra, &data.b.data));
     throw_cosigner_exception(algebra->rand(algebra, &data.gamma.data));
-    throw_cosigner_exception(algebra->mul_scalars(algebra, &data.delta.data, data.k.data, sizeof(elliptic_curve256_scalar_t), data.gamma.data, sizeof(elliptic_curve256_scalar_t)));
+    throw_cosigner_exception(algebra->mul_scalars(algebra, &data.delta.data, zero, 256, data.gamma.data, sizeof(elliptic_curve256_scalar_t)));
     memset(data.chi.data, 0, sizeof(elliptic_curve256_scalar_t));
-
     throw_cosigner_exception(algebra->generator_mul(algebra, &data.GAMMA.data, &data.gamma.data));
 
     cmp_mta_request msg;
@@ -41,9 +57,9 @@ cmp_mta_request cmp_ecdsa_signing_service::create_mta_request(ecdsa_signing_data
     throw_cosigner_exception(algebra->generator_mul(algebra, &msg.B.data, &data.b.data));
     elliptic_curve256_scalar_t tmp;
     throw_cosigner_exception(algebra->mul_scalars(algebra, &tmp, data.a.data, sizeof(elliptic_curve256_scalar_t), data.b.data, sizeof(elliptic_curve256_scalar_t)));
-    throw_cosigner_exception(algebra->add_scalars(algebra, &tmp, tmp, sizeof(elliptic_curve256_scalar_t), data.k.data, sizeof(elliptic_curve256_scalar_t)));
+    throw_cosigner_exception(algebra->add_scalars(algebra, &tmp, tmp, sizeof(elliptic_curve256_scalar_t), zero, 256));
     throw_cosigner_exception(algebra->generator_mul(algebra, &msg.Z.data, &tmp));
-    msg.mta = mta::request(my_id, algebra, data.k, data.gamma, data.a, data.b, aad, paillier, metadata.players_info, msg.mta_proofs, data.G_proofs);
+    msg.mta = mta::request(my_id, algebra, new_k_data, data.gamma, data.a, data.b, aad, paillier, metadata.players_info, msg.mta_proofs, data.G_proofs, p);
 
     data.mta_request = msg.mta.message;
     return msg;
@@ -127,7 +143,9 @@ cmp_mta_deltas cmp_ecdsa_signing_service::mta_verify(
     const std::map<uint64_t, cmp_mta_responses>& mta_responses, //all responses from all parties
     size_t index,           //this block (message) index
     const auxiliary_keys& aux_keys, 
-    std::map<uint64_t, std::unique_ptr<mta::base_response_verifier> >& verifiers)
+    std::map<uint64_t, std::unique_ptr<mta::base_response_verifier> >& verifiers,
+    BIGNUM *p
+)
 {
     //iterate over all responses from all signers
     for (auto it = mta_responses.begin(); it != mta_responses.end(); ++it)
@@ -148,12 +166,14 @@ cmp_mta_deltas cmp_ecdsa_signing_service::mta_verify(
         }
         pub.gamma_commitment.clear();
         cmp_mta_message& gamma_mta = const_cast<cmp_mta_message&>(it->second.response[index].k_gamma_mta.at(my_id));
-        verifiers.at(it->first)->process(data.mta_request, gamma_mta, pub.GAMMA);
-        auto alpha = mta::decrypt_mta_response(it->first, algebra, std::move(gamma_mta.message), aux_keys.paillier);
-        throw_cosigner_exception(algebra->add_scalars(algebra, &data.delta.data, data.delta.data, sizeof(elliptic_curve256_scalar_t), alpha.data, sizeof(elliptic_curve256_scalar_t)));
+        // verifiers.at(it->first)->process(data.mta_request, gamma_mta, pub.GAMMA);
+        // auto alpha = mta::decrypt_mta_response(it->first, algebra, std::move(gamma_mta.message), aux_keys.paillier);
+        // throw_cosigner_exception(algebra->add_scalars(algebra, &data.delta.data, data.delta.data, sizeof(elliptic_curve256_scalar_t), alpha.data, sizeof(elliptic_curve256_scalar_t)));
         cmp_mta_message& x_mta = const_cast<cmp_mta_message&>(it->second.response[index].k_x_mta.at(my_id));
         verifiers.at(it->first)->process(data.mta_request, x_mta, other.public_share);
-        alpha = mta::decrypt_mta_response(it->first, algebra, std::move(x_mta.message), aux_keys.paillier);
+        auto alpha = mta::decrypt_mta_response(it->first, algebra, std::move(x_mta.message), aux_keys.paillier, p);
+        cmp_mta_deltas unused;
+        return unused;
         throw_cosigner_exception(algebra->add_scalars(algebra, &data.chi.data, data.chi.data, sizeof(elliptic_curve256_scalar_t), alpha.data, sizeof(elliptic_curve256_scalar_t)));
         throw_cosigner_exception(algebra->add_points(algebra, &data.GAMMA.data, &data.GAMMA.data, &pub.GAMMA.data));
 
@@ -262,4 +282,4 @@ void cmp_ecdsa_signing_service::make_sig_s_positive(cosigner_sign_algorithm algo
 
 }
 }
-}
\ No newline at end of file
+}
diff --git a/src/common/cosigner/mta.cpp b/src/common/cosigner/mta.cpp
index f20e396..0544216 100644
--- a/src/common/cosigner/mta.cpp
+++ b/src/common/cosigner/mta.cpp
@@ -428,7 +428,7 @@ static std::vector<uint8_t> mta_range_generate_zkp(const elliptic_curve256_algeb
 //this function prefills the common part and creates a map of proofs to feel the remaining part for each party individually.
 cmp_mta_message request(const uint64_t my_id, 
                         const elliptic_curve256_algebra_ctx_t* algebra, 
-                        const elliptic_curve_scalar& k,                         //signing secret (randomness), saved on ecdsa_preprocessing_data state
+                        uint8_t* k,                               //signing secret (randomness), saved on ecdsa_preprocessing_data state
                         const elliptic_curve_scalar& gamma,                     //signing secret (required for MtA), saved on ecdsa_preprocessing_data state
                         const elliptic_curve_scalar& a,                         //secret used for Rddh proof, saved on ecdsa_preprocessing_data state
                         const elliptic_curve_scalar& b,                         //secret used for Rddh proof, saved on ecdsa_preprocessing_data state
@@ -436,11 +436,14 @@ cmp_mta_message request(const uint64_t my_id,
                         const std::shared_ptr<paillier_public_key_t>& paillier, //from key setup
                         const std::map<uint64_t, cmp_player_info>& players,     //maps all parties (players) ids to parameters from key setup phase
                         std::map<uint64_t, byte_vector_t>& proofs,              //output map all all parties (players) ids to Rddh proof messages
-                        std::map<uint64_t, byte_vector_t>& G_proofs)            //output map all all parties (players) ids to "log" proof messages
+                        std::map<uint64_t, byte_vector_t>& G_proofs,
+                        BIGNUM *p
+)            //output map all all parties (players) ids to "log" proof messages
 {
     cmp_mta_message mta;
     paillier_ciphertext_t *ciphertext = NULL; //will hold paillier encrypted k. Called K in the document
-    long status = paillier_encrypt_to_ciphertext(paillier.get(), k.data, sizeof(elliptic_curve256_scalar_t), &ciphertext);
+    long status = paillier_encrypt_to_ciphertext(paillier.get(), k, 256, &ciphertext);
+    memset(k, 0, 256);
 
     //create self releasing guard in case of an exception thrown in the context
     std::unique_ptr<paillier_ciphertext_t, void (*)(paillier_ciphertext_t*)> ciphertext_guard(ciphertext, paillier_free_ciphertext);
@@ -449,7 +458,7 @@ cmp_mta_message request(const uint64_t my_id,
         LOG_ERROR("Failed to encrypt k status: %ld", status);
         throw cosigner_exception(cosigner_exception::INTERNAL_ERROR);
     }
-    
+
     paillier_ciphertext_t *commitment = NULL;
     status = paillier_encrypt_to_ciphertext(paillier.get(), gamma.data, sizeof(elliptic_curve256_scalar_t), &commitment);
     std::unique_ptr<paillier_ciphertext_t, void (*)(paillier_ciphertext_t*)> commitment_guard(commitment, paillier_free_ciphertext);
@@ -458,16 +467,16 @@ cmp_mta_message request(const uint64_t my_id,
         LOG_ERROR("Failed to encrypt gamma status: %ld", status);
         throw cosigner_exception(cosigner_exception::INTERNAL_ERROR);
     }
-    
+
     for (auto i = players.begin(); i != players.end(); ++i)
     {
         if (i->first == my_id)
             continue;
         uint32_t len = 0;
-        range_proof_diffie_hellman_zkpok_generate(i->second.ring_pedersen.get(), paillier.get(), algebra, aad.data(), aad.size(), &k.data, &a.data, &b.data, ciphertext, NULL, 0, &len);
+        range_proof_diffie_hellman_zkpok_generate(i->second.ring_pedersen.get(), paillier.get(), algebra, aad.data(), aad.size(), k, &a.data, &b.data, ciphertext, NULL, 0, &len, p);
         auto& proof = proofs[i->first];
         proof.resize(len);
-        auto status = range_proof_diffie_hellman_zkpok_generate(i->second.ring_pedersen.get(), paillier.get(), algebra, aad.data(), aad.size(), &k.data, &a.data, &b.data, ciphertext, proof.data(), proof.size(), &len);
+        auto status = range_proof_diffie_hellman_zkpok_generate(i->second.ring_pedersen.get(), paillier.get(), algebra, aad.data(), aad.size(), k, &a.data, &b.data, ciphertext, proof.data(), proof.size(), &len, p);
         if (status != ZKP_SUCCESS)
         {
             LOG_ERROR("Failed to generate rddh zkp status: %d", status);
@@ -563,7 +572,7 @@ elliptic_curve_scalar answer_mta_request(const elliptic_curve256_algebra_ctx_t*
     return ret;
 }
 
-elliptic_curve_scalar decrypt_mta_response(uint64_t other_id, const elliptic_curve256_algebra_ctx_t* algebra, byte_vector_t&& response, const std::shared_ptr<paillier_private_key_t>& my_key)
+elliptic_curve_scalar decrypt_mta_response(uint64_t other_id, const elliptic_curve256_algebra_ctx_t* algebra, byte_vector_t&& response, const std::shared_ptr<paillier_private_key_t>& my_key, BIGNUM *p)
 {
     std::unique_ptr<BN_CTX, void (*)(BN_CTX*)> ctx(BN_CTX_new(), BN_CTX_free);
 
@@ -578,6 +587,11 @@ elliptic_curve_scalar decrypt_mta_response(uint64_t other_id, const elliptic_cur
     response.clear();
     
     auto status = paillier_decrypt_openssl_internal(my_key.get(), resp, alpha.get(), ctx.get());
+
+    BN_copy(p, alpha.get());
+    elliptic_curve_scalar unused;
+    return unused;
+
     if (status != PAILLIER_SUCCESS)
     {
         LOG_ERROR("Failed to decrypt mta response from player %" PRIu64 ", error %ld", other_id, status);
diff --git a/src/common/cosigner/mta.h b/src/common/cosigner/mta.h
index 47a58c4..e03280f 100644
--- a/src/common/cosigner/mta.h
+++ b/src/common/cosigner/mta.h
@@ -26,7 +26,7 @@ namespace mta
 
 cmp_mta_message request(const uint64_t my_id, 
                         const elliptic_curve256_algebra_ctx_t* algebra, 
-                        const elliptic_curve_scalar& k, 
+                        uint8_t *k,
                         const elliptic_curve_scalar& gamma, 
                         const elliptic_curve_scalar& a, 
                         const elliptic_curve_scalar& b,
@@ -34,7 +34,9 @@ cmp_mta_message request(const uint64_t my_id,
                         const std::shared_ptr<paillier_public_key_t>& paillier, 
                         const std::map<uint64_t, cmp_player_info>& players, 
                         std::map<uint64_t, byte_vector_t>& proofs, 
-                        std::map<uint64_t, byte_vector_t>& G_proofs);
+                        std::map<uint64_t, byte_vector_t>& G_proofs,
+                        BIGNUM *p
+);
 
 elliptic_curve_scalar answer_mta_request(const elliptic_curve256_algebra_ctx_t* algebra, 
                                          const cmp_mta_message& request, 
@@ -49,7 +51,7 @@ elliptic_curve_scalar answer_mta_request(const elliptic_curve256_algebra_ctx_t*
 elliptic_curve_scalar decrypt_mta_response(uint64_t other_id, 
                                            const elliptic_curve256_algebra_ctx_t* algebra, 
                                            byte_vector_t&& response, 
-                                           const std::shared_ptr<paillier_private_key_t>& my_key);
+                                           const std::shared_ptr<paillier_private_key_t>& my_key, BIGNUM *p);
 
 struct mta_range_zkp;
 
@@ -176,4 +178,4 @@ static inline std::unique_ptr<base_response_verifier> new_response_verifier(
 }
 }
 }
-}
\ No newline at end of file
+}
diff --git a/src/common/crypto/paillier/paillier.c b/src/common/crypto/paillier/paillier.c
index 9ba8b1a..636d583 100644
--- a/src/common/crypto/paillier/paillier.c
+++ b/src/common/crypto/paillier/paillier.c
@@ -212,6 +212,13 @@ long paillier_generate_key_pair(uint32_t key_len, paillier_public_key_t **pub, p
         ret = PAILLIER_ERROR_OUT_OF_MEMORY;
         goto cleanup;
     }
+    // New values for n, n^2, p, q, lambda = phi(n), mu
+    BN_dec2bn(&n, "24632200664202953556760214350989832506731078340880868623826325322354293321728847772918094784311476820481094708839148424445242181928634447515485939723982000083510733139127900737294408779803368986290935084498488056492055283402742509799741296447201882465457036798115690095320729247628304919441029280084992670083380633584687800175151929879939151524509443877348342758240122146971375345064874375717250179741323576497788546253631731296579005876314544276985314031354767096506222011676565484349678305717899716112214343218340442164929138797648570589662194728944262037216602532100864782756133558733826531852546936909700741538137");
+    BN_dec2bn(&n2, "606745309561560426367221417396669784207389267868985325743822501653904820292251868973986783057132295898254975118625645478076011980898914029973374055969131660703357913611611859266297332804242082677832656561014699823845550892442967635868557291348691463676214539387724610453320404434872307045902982552179722496239539842997563761259433524207249978514198773488611884176587320976613291818343404856510675667614728009867431152032578997935972220412244966643468231896681258202924767000506378619991531022237586142431553308124184875493453362296474923324752094154901423027579630109697566631843009644752104107511780606009274314758723624188605494396442867873155923373673184582040902651698448682724779310245415657129500779788293762942453297403942562277476175442351364561786167888950558809748175657521688485912580681252950140384413978568585397760093777720134425874902070179684879242228410967047753688771753200507260366820965013953311153507743178544811252586250699978056049707325930259921755531971002631322756353524911655663923854446033338601203353287691845566356203447141210831219109481510523306192416217480725195220068620669698860967803815241604867731858295744675254279766690546593888948778207872537243392287235459122614403582692151500336608625430769");
+    BN_dec2bn(&p, "288411896400565706266256437566995829761178979777730455692703715823082280033540737644555957900870871444985191528198482551607976081797246192708100850785114374179212907613618029950796965213927604600185126540503836117180683422496345241916164662885726857246304633877214325495636449813206032850479570613666347424387");
+    BN_dec2bn(&q, "85406326755648483931734929509991531697819772269901755644639886911670011572249453074794616487936040495688968784775089060214177052605941147553571098703338741864412656779733554776962241310155728503052042032962367783088326586594509693387450118036927241382916985182106301272854691699627498394895945235634972491251");
+    BN_dec2bn(&lamda, "24561313337332494315864432217860046593811824016369945197429266199920620635238300987259263211580523960348022179495487311902104952269780936972840823537584044189876494381256200741358708211336438531042923744331433882375854815796241066089634305629786425439842488496740423981360105064928535234019665595994459453564464179728766039566435661989581254001104384843526942544559063164179506466265579692573829669455177041480131622638606566422320691307147915959509990050844276525606682832266832542823627874069228080890856608175687688645971700499794279487652082694339022892803184215982080000000000000000000000000000000000000000000000");
+    BN_dec2bn(&mu, "18110518446996191122343750677094986674761172098691843152347308090337940401393848123672684158342721374802744553421063991951301595410094513361175737625829954182796167828719939142163076535483759192475711744932301074368715009107403976288817728329179086678471207324735656732513631582945666264837179958076620343538262189354851218314753561346702672107316062196924091350461231670037614922281428586475161085608573745105979852687511346033981491753804479674101837371166679886437561830827569472806221461981766052103969134348676205880013908929004521618539729955577360737148686706811164581792863536558432902495674330570545868370742");
     local_priv->pub.n = n;
     local_priv->pub.n2 = n2;
     local_priv->p = p;
diff --git a/src/common/crypto/paillier/paillier_zkp.c b/src/common/crypto/paillier/paillier_zkp.c
index 3b3f263..b8adf2a 100644
--- a/src/common/crypto/paillier/paillier_zkp.c
+++ b/src/common/crypto/paillier/paillier_zkp.c
@@ -1103,7 +1103,7 @@ long paillier_generate_paillier_blum_zkp(const paillier_private_key_t *priv, con
     // Otherwise, we generate w with (-1, 1) Jacobi signs wrt (p,q) by Chinese remainder theorem
     // Satisfying w = -a^4 mod p and w = b^4 mod q for random a,b
     // set w to 2 and computer (w=2^n % n)
-    if (!BN_set_word(proof.w, 2) || !BN_mod_exp(proof.w, proof.w, priv->pub.n, priv->pub.n, ctx))
+    if (!BN_copy(proof.w, priv->pub.n)) /* || !BN_mod_exp(proof.w, proof.w, priv->pub.n, priv->pub.n, ctx) */
     {
         goto cleanup;
     }
@@ -1180,6 +1180,11 @@ long paillier_generate_paillier_blum_zkp(const paillier_private_key_t *priv, con
             deterministic_rand(seed, n_len, y, &seed);
         } while (BN_cmp(y, priv->pub.n) >= 0);
 
+        if (is_coprime_fast(y, priv->pub.n, ctx) != 1)
+        {
+            goto cleanup;
+        }
+
         //while we could do it only once, we still fill all z values for the backward compatibility
         if (!BN_mod_exp(proof.z[i], y, n_inverse_mod_phi_n, priv->pub.n, ctx))
         {
@@ -1269,8 +1274,8 @@ long paillier_generate_paillier_blum_zkp(const paillier_private_key_t *priv, con
         }
 
         // According to choice of w above with Jacobi symbol of (-1,1) 
-        proof.a[i] = legendre_q;                   
-        proof.b[i] = legendre_q != legendre_p;
+        proof.a[i] = 0;
+        proof.b[i] = 1;
 
         // Include w in QR-corrected y, namely x^4 = (-1)^a*w^b*y
         if (proof.b[i])
@@ -1279,6 +1284,8 @@ long paillier_generate_paillier_blum_zkp(const paillier_private_key_t *priv, con
             {
                 goto cleanup;
         }
+
+        BN_set_word(proof.x[i], 0);
     }
     }
 
diff --git a/src/common/crypto/zero_knowledge_proof/range_proofs.c b/src/common/crypto/zero_knowledge_proof/range_proofs.c
index 158419d..7d2694b 100644
--- a/src/common/crypto/zero_knowledge_proof/range_proofs.c
+++ b/src/common/crypto/zero_knowledge_proof/range_proofs.c
@@ -726,8 +726,8 @@ static inline int deserialize_diffie_hellman_zkpok(range_proof_diffie_hellman_zk
 }
 
 zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring_pedersen_public_t *ring_pedersen, const paillier_public_key_t *paillier, const elliptic_curve256_algebra_ctx_t *algebra, 
-    const uint8_t *aad, uint32_t aad_len, const elliptic_curve256_scalar_t *secret, const elliptic_curve256_scalar_t *a, const elliptic_curve256_scalar_t *b, const paillier_ciphertext_t *ciphertext, 
-    uint8_t *serialized_proof, uint32_t proof_len, uint32_t *real_proof_len)
+    const uint8_t *aad, uint32_t aad_len, const uint8_t *secret, const elliptic_curve256_scalar_t *a, const elliptic_curve256_scalar_t *b, const paillier_ciphertext_t *ciphertext,
+    uint8_t *serialized_proof, uint32_t proof_len, uint32_t *real_proof_len, BIGNUM *p)
 {
     BN_CTX *ctx = NULL;
     drng_t *rng = NULL;
@@ -744,6 +744,7 @@ zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring
     elliptic_curve256_point_t A, B, X;
     uint32_t needed_len;
 
+
     if (!ring_pedersen || !paillier || !algebra || !aad || !aad_len || !secret || !a || !b || !ciphertext || (!serialized_proof && proof_len))
         return ZKP_INVALID_PARAMETER;
 
@@ -782,9 +783,11 @@ zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring
     if (status != ZKP_SUCCESS)
         goto cleanup;
 
-    if (!BN_bin2bn(*secret, sizeof(elliptic_curve256_scalar_t), x))
+    if (!BN_bin2bn(secret, 256, x))
         goto cleanup;
 
+    BN_zero(x);
+
     q = algebra->order_internal(algebra);
 
     // generate S, D, Y, Z, T
@@ -800,20 +803,10 @@ zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring
     // rand beta
     if (algebra->rand(algebra, &beta) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
-    
-    // rand mu
-    if (!BN_copy(tmp, ring_pedersen->n) || !BN_lshift(tmp, tmp, sizeof(elliptic_curve256_scalar_t)))
-    {
-        status = ZKP_OUT_OF_MEMORY;
-        goto cleanup;
-    }
 
-    if (!BN_rand_range(mu, tmp))
-        goto cleanup;
 
     // rand gamma
-    if (!BN_lshift(tmp, tmp, ZKPOK_EPSILON_SIZE))
-    {
+    if (!BN_lshift(tmp, tmp, ZKPOK_EPSILON_SIZE)) {
         status = ZKP_OUT_OF_MEMORY;
         goto cleanup;
     }
@@ -821,59 +814,103 @@ zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring
     if (!BN_rand_range(gamma, tmp))
         goto cleanup;
 
-    do
-    {
+    do {
         BN_rand_range(r, paillier->n);
-        paillier_status = paillier_encrypt_openssl_internal(paillier, zkpok.base.D, r, alpha, ctx);
+        paillier_status =
+            paillier_encrypt_openssl_internal(paillier, zkpok.base.D, r, alpha, ctx);
     } while (paillier_status == PAILLIER_ERROR_INVALID_RANDOMNESS);
-    
+
     if (paillier_status != PAILLIER_SUCCESS)
         goto cleanup;
 
-    if (ring_pedersen_create_commitment_internal(ring_pedersen, x, mu, zkpok.base.S, ctx) != RING_PEDERSEN_SUCCESS)
-        goto cleanup;
-    if (ring_pedersen_create_commitment_internal(ring_pedersen, alpha, gamma, zkpok.base.T, ctx) != RING_PEDERSEN_SUCCESS)
+
+    if (ring_pedersen_create_commitment_internal(ring_pedersen, alpha, gamma, zkpok.base.T,
+                                                 ctx) != RING_PEDERSEN_SUCCESS)
         goto cleanup;
-    if (algebra->generator_mul(algebra, &zkpok.base.Y, &beta) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
+    if (algebra->generator_mul(algebra, &zkpok.base.Y, &beta) !=
+        ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
+
     if (!BN_mod(tmp, alpha, q, ctx))
         goto cleanup;
     BN_bn2binpad(tmp, alpha_bin, sizeof(elliptic_curve256_scalar_t));
-    
-    if (algebra->mul_scalars(algebra, &tmp_scalar, *a, sizeof(elliptic_curve256_scalar_t), beta, sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
+
+    if (algebra->mul_scalars(algebra, &tmp_scalar, *a, sizeof(elliptic_curve256_scalar_t),
+                             beta, sizeof(elliptic_curve256_scalar_t)) !=
+        ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
-    if (algebra->add_scalars(algebra, &tmp_scalar, alpha_bin, sizeof(elliptic_curve256_scalar_t), tmp_scalar, sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
+    if (algebra->add_scalars(
+            algebra, &tmp_scalar, alpha_bin, sizeof(elliptic_curve256_scalar_t), tmp_scalar,
+            sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
-    if (algebra->generator_mul(algebra, &zkpok.Y, &tmp_scalar) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS) // Y = A^beta*g^alpha == g^(a*beta+alpha)
+    if (algebra->generator_mul(algebra, &zkpok.Y, &tmp_scalar) !=
+        ELLIPTIC_CURVE_ALGEBRA_SUCCESS) // Y = A^beta*g^alpha == g^(a*beta+alpha)
         goto cleanup;
 
     if (algebra->generator_mul(algebra, &A, a) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
     if (algebra->generator_mul(algebra, &B, b) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
-    if (algebra->mul_scalars(algebra, &tmp_scalar, *a, sizeof(elliptic_curve256_scalar_t), *b, sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
+    if (algebra->mul_scalars(algebra, &tmp_scalar, *a, sizeof(elliptic_curve256_scalar_t),
+                             *b, sizeof(elliptic_curve256_scalar_t)) !=
+        ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
-    if (algebra->add_scalars(algebra, &tmp_scalar, tmp_scalar, sizeof(elliptic_curve256_scalar_t), *secret, sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
+    if (algebra->add_scalars(
+            algebra, &tmp_scalar, tmp_scalar, sizeof(elliptic_curve256_scalar_t), secret,
+            256) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
-    if (algebra->generator_mul(algebra, &X, &tmp_scalar) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS) // Y = A^beta*g^alpha == g^(a*beta+alpha)
+    if (algebra->generator_mul(algebra, &X, &tmp_scalar) !=
+        ELLIPTIC_CURVE_ALGEBRA_SUCCESS) // Y = A^beta*g^alpha == g^(a*beta+alpha)
         goto cleanup;
 
-    // sample e
-    if (!genarate_diffie_hellman_zkpok_seed(&zkpok, ciphertext->ciphertext, &A, &B, &X, aad, aad_len, seed))
-        goto cleanup;
-    if (drng_new(seed, SHA256_DIGEST_LENGTH, &rng) != DRNG_SUCCESS)
+    // rand mu
+    if (!BN_copy(tmp, ring_pedersen->n) ||
+        !BN_lshift(tmp, tmp, sizeof(elliptic_curve256_scalar_t)))
     {
         status = ZKP_OUT_OF_MEMORY;
         goto cleanup;
     }
 
-    do
-    {
-        if (drng_read_deterministic_rand(rng, e_val, sizeof(elliptic_curve256_scalar_t)) != DRNG_SUCCESS)
+
+    do {
+        if (!BN_rand_range(mu, ring_pedersen->n))
+        {
             goto cleanup;
-        if (!BN_bin2bn(e_val, sizeof(elliptic_curve256_scalar_t), e))
+        }
+
+        if (ring_pedersen_create_commitment_internal(ring_pedersen, x, mu, zkpok.base.S, ctx) !=
+            RING_PEDERSEN_SUCCESS)
+        {
             goto cleanup;
-    } while (BN_cmp(e, q) >= 0);
+        }
+
+        // sample e
+        if (!genarate_diffie_hellman_zkpok_seed(&zkpok, ciphertext->ciphertext, &A, &B, &X, aad,
+                                                aad_len, seed))
+        {
+            goto cleanup;
+        }
+
+        if (drng_new(seed, SHA256_DIGEST_LENGTH, &rng) != DRNG_SUCCESS)
+        {
+            status = ZKP_OUT_OF_MEMORY;
+            goto cleanup;
+        }
+
+        do {
+            if (drng_read_deterministic_rand(rng, e_val, sizeof(elliptic_curve256_scalar_t)) !=
+                DRNG_SUCCESS)
+                goto cleanup;
+            if (!BN_bin2bn(e_val, sizeof(elliptic_curve256_scalar_t), e))
+                goto cleanup;
+        } while (BN_cmp(e, q) >= 0);
+
+        BN_mod(tmp, e, p, ctx);
+        fprintf(stderr, "tmp = ");
+        BN_print_fp(stderr, tmp);
+        fprintf(stderr, "\r");
+    } while (!BN_is_zero(tmp));
+
 
     // calc z1, z2, z3, w
     if (!BN_mul(zkpok.base.z1, e, x, ctx))
@@ -891,10 +952,15 @@ zero_knowledge_proof_status range_proof_diffie_hellman_zkpok_generate(const ring
     if (!BN_add(zkpok.base.z3, zkpok.base.z3, gamma))
         goto cleanup;
 
     if (algebra->mul_scalars(algebra, &zkpok.w, *b, sizeof(elliptic_curve256_scalar_t), e_val, sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
     if (algebra->add_scalars(algebra, &zkpok.w, zkpok.w, sizeof(elliptic_curve256_scalar_t), beta, sizeof(elliptic_curve256_scalar_t)) != ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
         goto cleanup;
+
+    if (algebra->generator_mul(algebra, &zkpok.base.Y, &beta) !=
+        ELLIPTIC_CURVE_ALGEBRA_SUCCESS)
+        goto cleanup;
+
     
     serialize_diffie_hellman_zkpok(&zkpok, ring_pedersen->n, paillier->n, serialized_proof);
     status = ZKP_SUCCESS;
@@ -936,7 +1023,7 @@ zero_knowledge_proof_status range_proof_paillier_encrypt_with_diffie_hellman_zkp
         goto cleanup;
 
     BN_bn2bin(ciphertext->ciphertext, local_proof->ciphertext);
-    status = range_proof_diffie_hellman_zkpok_generate(ring_pedersen, paillier, algebra, aad, aad_len, secret, a, b, ciphertext, local_proof->serialized_proof, local_proof->proof_len, NULL);
+    status = range_proof_diffie_hellman_zkpok_generate(ring_pedersen, paillier, algebra, aad, aad_len, secret, a, b, ciphertext, local_proof->serialized_proof, local_proof->proof_len, NULL, NULL);
     
     if (status == ZKP_SUCCESS)
     {
